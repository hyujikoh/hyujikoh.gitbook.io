# WIL: 이번주 공부 (2월 3주차)

블로그 글 내용 확인했어. 기존 WIL 포맷에 맞춰서 작성할게.

***

## **2월 3주차 WIL 정리**

### **배웠던 점**

1. **로그는 "켜는 것"보다 "끄는 것"이 설계다**

서비스 트래픽이 늘면서 불필요한 로그가 정작 봐야 할 로그를 파묻는 문제가 생겼습니다. Swagger UI 리소스 요청이 수십 줄씩 쌓이고, 단순 SELECT 쿼리가 로그 대부분을 차지하고 있었습니다. "정보는 많이 남겨두는 게 좋다"고 생각했는데, 실제로는 필요한 로그만 남아 있어야 모니터링이 가능하다는 걸 체감했습니다.

2. **Hibernate SQL과 P6Spy의 중복 구조 정리**

운영 서버에서 같은 쿼리가 두 번씩 출력되고 있었습니다. Hibernate SQL은 JPA 내부에서 `?` 플레이스홀더 상태로 기록하고, P6Spy는 JDBC 프록시 레이어에서 바인딩된 완성 SQL을 기록하는 구조라서 캡처 위치 자체가 다릅니다. P6Spy가 기능적으로 상위 호환이라 Hibernate SQL은 전체 프로필에서 `warn`으로 비활성화하고, P6Spy는 개발 환경에서만 활성화하되 운영에서는 `enable-logging: false`로 프록시 래핑 자체를 막는 방식으로 정리했습니다.

3. **Logbook의 glob 패턴과 HTTP 메서드 필터링**

기존에 Swagger 리소스를 개별 파일 20개로 나열해서 제외하고 있었는데, 새로 추가되는 리소스는 매번 빠지고, URL 인코딩 불일치(`Generated API` vs `Generated%20API`)로 매칭 자체가 안 되는 문제도 있었습니다. Logbook 내부의 `Glob.compile()`이 Ant 스타일 패턴을 지원한다는 걸 바이트코드 분석으로 확인하고, `/swagger-ui/**` 같은 glob 패턴 5개로 줄이니 누락 없이 전부 매칭되었습니다. 추가로 GET 요청도 제외해서 실제 추적이 필요한 POST/PUT/DELETE만 로깅하도록 개선했습니다.

4. **HTTP 계층과 SQL 계층의 필터링은 독립적이다**

Logbook에서 GET을 제외해도 해당 요청이 트리거한 SELECT 쿼리는 P6Spy에서 그대로 출력됩니다. 각 계층의 로그는 각 계층의 도구로 필터링해야 한다는 당연한 사실을, 직접 겪고 나서야 제대로 체감했습니다.

5. **P6Spy SELECT 필터링 — 4번 실패하고 근본 원인을 찾은 과정**

P6Spy에서 SELECT를 제외하기 위해 `formatMessage`에서 빈 문자열 반환 → 커스텀 Appender → yml `log-filter.pattern` → `spy.properties` 네이티브 설정 순서로 시도했습니다. 시도 1\~3이 실패한 근본 원인은 `p6spy-spring-boot-starter`의 `@PostConstruct`에서 `reload()`가 설정을 덮어씌우는 구조 때문이었습니다. 최종적으로 Spring Boot 자동 설정을 우회하고 P6Spy가 직접 파싱하는 `spy.properties`에 `filter=true`와 `sqlexpression`을 설정해서 해결했습니다. 공식 문서에 답이 없을 때 `javap -c -p`로 바이트코드를 직접 확인하는 게 가장 확실한 디버깅 방법이라는 걸 배웠습니다.

### **아쉬웠던 점**

1. **P6Spy yml 설정 실패 원인을 끝까지 규명하지 못한 점**

시도 3에서 yml의 `log-filter.pattern`이 `System.setProperty`로 정상 변환되는 것까지는 확인했지만, 그럼에도 동작하지 않은 정확한 원인(Spring Boot의 `Pattern` 타입 바인딩 변형인지, `reload()` 타이밍 문제인지)을 끝까지 특정하지 못했습니다. `spy.properties`로 우회해서 해결은 했지만, 근본 원인을 모르고 넘어간 부분이 찝찝하게 남아있습니다.

2. **운영 환경에서의 SQL 로깅 전략이 아직 미완성인 점**

현재 운영에서는 P6Spy 자체를 꺼놓았는데, 장애 상황에서 SQL 추적이 필요한 경우의 대응 방안이 아직 구체적으로 마련되지 않았습니다. 슬로우 쿼리 로그를 DB 레벨에서 별도로 수집하거나, 필요 시 P6Spy를 동적으로 활성화할 수 있는 구조까지 고려해보면 좋을 것 같습니다.

