---
hidden: true
---

# 2월 1주차

시니어 가 주니어에게 지시하는 것처럼 해야한다.





이번주 면접 준비



cs 준비

1. 브라우저에 주소 또는 ip 를 입력했을때 과정에 대해서 설명해봐라

```
브라우저에 url 정보를 입력 한다고 하면 전체적으로 3가지 과정을 수행합니다.
첫번째로 dns 조회 하고 tcp 연결 그리거 http 요청 전송

dns 정보는 유저가 입력한 도메인 주소를 dns 서버에서 ip 주소로 바꾸는 과정을 진행합니다.

이때도 바로 dns 서버로 접속하는것이 아니라  순차적으로 진행을 하는데 
 첫번쨰로 브라우저 캐시에서 ip 정보를 저장하고 있으면 이를 사용합니다. 
 두번째로 1이 없으면 os 캐시에 저장된 dns 캐시를 확인합니다.
 이것도 없으면 
 세번째로 호스트 파일을 통해 저장되어 있는 dns 매핑 정보를 확인하여 사용합니다.
 그래도 없으면 이제 기기에 저장된 dns 서버로 쿼리를 보내서 ip 정보를 가져오는 방식을 채용합니다.
 
 
 이렇게 가져온 ip 정보를 통해 서버와 tcp 연결을 3 핸드쉐이킹으로 연결 수립을 합니다.
 
 1. 연결해줘 syn(클라이언트)
 2. ok ack and syn(서버)
 3. 연결됐다! ack(클라이언트)
 
 그렇게 준비된 연결 상태를 통해 http 요청을 보내서 응답되는 과정을 통해 네이버 페이지로 보여지는 결과가 나옵니다.
 
 그렇다면 http 통신이 여러개 있는데 이거에 대해서 설명해줄수있을까?
 
 자 
 태초의 http 0.9 부터 3 까지 부족하지만 아는 부분에 대해서 답을 해드리겠습니다.
 
 0.9 요청이 오로지 GET 요청만 전송이 가능했고, 헤더랑 상태코드도 없었습니다. 오로지 html 문자열만 보여줄수있고 
 이미지나 다른 파일은 전송 할수 없었습니다. 즉 처음 http 통신의 초창기는 정만 단순한 문서 형태만 보여주는 방식이었습니다.
 주요 특징 :: 오로지 문서 표현만 가능
 
 
 1.0 때부터는 헤더가 생기면서  content-type 포맷을 통해 다양한 리소스들을 전송하는것이 가능하게 되었습니다.
 이떄 POST ,HEAD 메서드가 추가되어 데이터 전송도 가능하게 되었습니다. 
 주요 특징 : 헤더라는 개념이 처음 도입
 문제는 연결을 재사용 하는것이 불가능 했습니다. 하나를 요청할때마다 TCP 연결을 맺고 끊는 과정을 반복해 속도면에서 단점이 있습니다.
 
 
 1.1 때무터 keep -alive 라는것이 도입 되어서, 연결을 끊지 않고 재사용하는것이 가능하게 되었습니다. 단 단일 파이프라인 통신이라서 
 단하나의 요청이 지연되는 현상이 있으면 뒤에 연달아 대기하는 요청들도 동일하게 지연되는 문제가 발생하였습니다. 
 
 이런 문제가 2.0 때부터 해결이 되었는데 바로 멀티플렉싱 통신이 가능하게 되었습니다.
 다중화 연결을 통해 한 연결안에 여러 요청을 동시에 주고 받는게 가능해서 1.0 떄 대기 지연 문제를 해결하게 되었습니다. 
 또한 이전에 문자화 형식으로 전송되던걸 이진 프로토콜을 통해 컴퓨터가 파싱하기 좋은 바이너리로 전송하는것으로 바뀌었습니다.
 
 3.0 에서는 이전 tcp 통신 대신 QUIC 를 사용하게 되었습니다. 
 아무리 다중화 연결을 한다 했어도 TCP 자체의 패킷 순서 보장 때문에 발생되는 지연문제가 3.0 에서 해결하게 되었습니다. 
 비신뢰성이기때문에 패킷 하나가 손실 되더라도 다른 스트림은 영향을 받디 않게 되었습니다.
 결국 핵심은 UDP 로도 신뢰성있는 통신을 가능하게 되었다는게 핵심이었습니다. 
 가령 tcp 에서 통신 응답이 안올걸 재 전송 하게 되었을떄 응답이 되는게 처음건지 두번째인건지 확인 불가능하였다.
 quic 는 재전송 할때 응답되는 패킷 번호를 붙여서 응답 할떄 어떤 요청인지 확인이 가능했다.

 
```





프로젝트 별 구조적인 답변 <br>

1. mes 프로젝트&#x20;

```
프로젝트 를 소개 해봐라

mes 는 기존에 있던 제조 관리 레거시 솔루션을 고도화 한 프로젝트 입니다. 기존에 화면 중심에 비즈니스 로직, sql , 
화면 코드가 뒤섞은 클래스가 빈번하게 존재하던 구조를 도메인 기반 아키텍처로 전환하고, 고객사 별로 데이터 격리를 위한 멀티 테넌시 인프라를 
설계한 구조 입니다. 

왜 이 아키텍처 인가
기존 레거시 는 요청과 응답을 map 형태로 받을뿐만 아니라 심지어 controller 에서 유즈케이스 , 
db 저장 까지 모든걸 수행하는 로직이 담긴 클래스 메소드가 빈번하게 설계되었습니다.
이때문에 로직 재사용이 불가능했고, 정책등 업데이트가 될 경우에 어디로 영향이 가는지 파악이 불가능 했습니다.
이를 위해서 각각 기획과 PM 비즈니스 관련된 사람들과 mes 서비스에 대한 정책 , 요구사항등을 정의 하여 
각각의 도메인이 명확한 책임을 가질수 있다는것이 가능하다 판단이 들었고, 팀원들과 같이 이번 구조에 대해서 구현하게 되었습니다.
핵심 


멀티테넌시 기반으로 설명해달라


  3단계까지 이야기한다면, 문제 인식 → 즉시 대응 → 근본 개선 흐름으로 자연스럽게 풀어가는 게 좋습니다.


  "현재 저희 시스템은 단일 DataSource에서 스키마만 전환하는 구조라, 모든 테넌트가 하나의 커넥션 풀과 DB 인스턴스를 공유합니다. 그래서 특정 테넌트가 무거운 쿼리를 대량으로 실행하면 다른 테넌트까지 영향을 받는, Noisy Neighbor 문제가 발생할 수 있다는 점을 인지하고
  있습니다.

  우선 즉시 적용할 수 있는 건 애플리케이션 레벨의 방어입니다. 테넌트별 커넥션 점유 수를 제한하고, 
  API Rate Limiting을 걸어서 한 테넌트가 리소스를 독점하지 못하게 막는 거죠. 쿼리 타임아웃도 설정해서 비정상적으로 오래 걸리는 쿼리는 강제 종료시킵니다. 
  이것만으로 장애를 완전히 막지는 못하지만, 피해 범위를 줄이는 효과가 있습니다.

  다음으로는 테넌트별 모니터링을 구축할 것 같습니다. 현재는 어떤 테넌트가 얼마나 리소스를 사용하는지 추적할 수 없어서, 문제가 터져야 인지하게 됩니다. 테넌트별 쿼리 실행 시간이나 커넥션 사용량 같은 메트릭을 수집하면, 임계치 초과 시 사전에 알림을 받고 대응할 수 있습니다.

  근본적으로는 Read/Write 분리를 도입할 것 같습니다. 실제로 부하를 유발하는 건 대부분 통계나 리포트 같은 무거운 조회 쿼리인데, 이걸 Read Replica로 분산시키면 Primary DB에 대한 부담이 크게 줄어듭니다. 저희 프로젝트에서도 복잡한 통계 쿼리 처리를 위해 CQRS 도입을 검토하게
  된 배경이 이 부분입니다."

  ---
  이 답변이 좋은 이유
  ┌─────────────────────────────────────┬────────────────────────────────────┐
  │                요소                 │         어떤 인상을 주는가         │
  ├─────────────────────────────────────┼────────────────────────────────────┤
  │ "Noisy Neighbor 문제"               │ 용어를 알고 있다 → 개념 이해도     │
  ├─────────────────────────────────────┼────────────────────────────────────┤
  │ 즉시/중기/근본 단계 구분            │ 현실적 사고 → 실무 감각            │
  ├─────────────────────────────────────┼────────────────────────────────────┤
  │ "이것만으로 완전히 막지는 못하지만" │ 각 방법의 한계를 안다 → 깊이       │
  ├─────────────────────────────────────┼────────────────────────────────────┤
  │ CQRS 도입 검토 배경 연결            │ 본인 프로젝트 경험과 연결 → 진정성 │
  └─────────────────────────────────────┴────────────────────────────────────┘
  ---
  꼬리 질문 대비

  면접관이 더 파고들 수 있는 포인트들입니다:

  "Rate Limiting은 구체적으로 어떻게?"
  "Spring에서 Bucket4j나 Resilience4j 같은 라이브러리로 테넌트 식별자 기준으로 요청을 제한할 수 있습니다. 현재 JWT에 factoryCode가 있으니 이걸 키로 사용하면 됩니다."

  "Read Replica 도입하면 정합성 문제는?"
  "쓰기 직후 읽기에서 Replication Lag으로 인해 최신 데이터가 안 보일 수 있습니다. 이건 쓰기 직후에는 Primary에서 읽도록 라우팅하거나, 사용자에게 즉시 반영이 필요한 화면에서만 Primary를 사용하는 식으로 대응할 수 있습니다."

  "그 이상으로 더 확장해야 한다면?"
  "테넌트 티어링을 고려할 것 같습니다. 부하가 큰 대형 테넌트를 별도 DB 인스턴스로 분리하고, 테넌트별로 DataSource를 라우팅하는 구조로 확장하는 거죠."

  ---
  3단계까지만 이야기하되, 꼬리 질문이 오면 4단계(티어링)까지 자연스럽게 확장하는 형태가 가장 이상적입니다. **"다 알지만 현실적인 순서를 판단할 줄 안다"**는 인상을 주는 게 핵심입니다.

```
