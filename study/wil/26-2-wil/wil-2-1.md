# WIL: 이번주 공부 (2월 1주차)

## **이번주 WIL 정리**

### **배웠던 점**

1. **브라우저에 URL을 입력했을 때의 전체 흐름 정리**

CS 공부를 계기로 DNS 조회 → TCP 연결 → HTTP 요청 전송, 이 세 단계를 처음부터 다시 정리했습니다.

특히 DNS 조회가 한 번에 DNS 서버로 가는 게 아니라 브라우저 캐시 → OS 캐시 → hosts 파일 → DNS 서버 순서로 단계적으로 fallback 된다는 점을 명확하게 잡을 수 있었습니다. TCP 3-way handshake도 SYN → SYN+ACK → ACK 흐름을 단순 암기가 아니라 "왜 3번이어야 하는가"까지 생각해보면서 정리했습니다.

2. **HTTP 버전별 진화 흐름 파악**

0.9부터 3.0까지 쭉 훑었는데, 결국 핵심은 "연결 비용을 어떻게 줄이느냐"라는 하나의 문제를 계속 개선해온 흐름이라는 걸 느꼈습니다.

* 0.9: GET만 가능, 헤더도 상태코드도 없는 순수 문서 전송
* 1.0: 헤더 도입으로 다양한 리소스 전송 가능, 하지만 매 요청마다 TCP 연결/해제 반복
* 1.1: Keep-Alive로 연결 재사용 가능, 하지만 단일 파이프라인이라 HOL Blocking 발생
* 2.0: 멀티플렉싱으로 하나의 연결에서 동시 요청/응답, 바이너리 프로토콜 전환
* 3.0: QUIC(UDP 기반)으로 전환하여 TCP 레벨의 HOL Blocking까지 해결

특히 HTTP/2가 멀티플렉싱을 도입했음에도 TCP 자체의 패킷 순서 보장 때문에 지연이 완전히 해결되지 못했고, 그래서 3.0에서 QUIC으로 전환한 맥락이 연결되면서 이해가 깊어졌습니다.

3. **JVM 기본 구조 정리**

.java → 컴파일 → .class(바이트코드) → 클래스 로더가 런타임 데이터 영역에 로드 → 실행 엔진이 실행. JVM은 결국 "바이트코드 실행기"라는 한 문장으로 정리할 수 있었습니다. 클래스 로더의 계층 구조(부트스트랩 → 확장 → 애플리케이션)와 위임 모델까지 정리했습니다.

### **아쉬웠던 점**

1. **JVM 의 GC 영역까지 정리하지 못한 점**

JVM 기본 구조는 잡았지만, GC 동작 방식(Young/Old Generation, Minor/Major GC 등)까지는 이번 주에 정리하지 못했습니다. 다음 주에 GC 알고리즘별 특징과 실무에서 튜닝이 필요한 상황까지 이어서 정리할 계획입니다.

2. **개념을 코드로 검증하지 못한 점**

HTTP 버전 차이나 JVM 구조를 글로만 정리하다 보니, 실제로 체감하면서 학습한 부분이 부족했습니다. 예를 들어 HTTP/1.1과 2.0의 성능 차이를 간단한 벤치마크로 확인해보거나, 클래스 로더 동작을 디버거로 추적해보는 식의 실습을 병행했으면 더 깊이 있는 학습이 되었을 것 같습니다.
