# WIL: 적당한 방법과 그걸 위한 도구 (aka Redis ZSET)

기간 : 2025/12/22 \~ 2025/12/27

### 1. 가장 오래 붙잡았던 고민

이번 주는 실시간 데이터를 어디까지 RDB에 맡기고, 어디서부터 Redis라는 캐싱 을 맡기는가에 대해서 \
계속 고민했습니다

이세상에 모든 서비스는 Spring + MySQL 로 해결이 가능하다고 맹신했던 사람으로서, \
이가 없으면 잇몸으로 불편한게 있어도 그냥 감수라고 지내라는 생각이었습니다.&#x20;

그러나 결국에 적절한 기법과 그에 맞는 최적의 기법을 사용하는것이 중요하다 인지했고,\
이번 실시간 데이터(랭킹) 데이터를 구현 및 적용하는것을 고민해봤습니다.

MySQL만으로 했다면 발생할 GROUP BY + ORDER BY의 풀스캔의 문제점을 인식하고 그에대한 대안점으로 사용한 \
인메모리 DB 중에서 Redis 싱글 스레드 구조 → epoll → ZSET까지 차근차근 이해하면서\
"이 도구가 정말 내 문제에 맞나?"를 스스로 납득해 가는 과정을 지냈습니다.

### 2. 시도한 것들과 아쉬웠던 점

**만족스러웠던 점:**

* 가중치 모델(조회 0.1, 좋아요 0.2, 구매 0.6\*log)은 나름 합리적이었다고 생각합니다. 특히 비용 등 구매에 대해서 과도한 수치를 가중하는것에 대비한 log 정규화를 적용한점은 만족스러웠습니다.
* Carry-Over(23:50 상위 100개 10%) + Fallback(오늘→어제)으로 Cold Start 대비 하는 패턴을 고민하고 \
  비즈니스로직에 적용한 점이 만족스러웠습니다.
* DDD 계층 분리(Kafka→Facade→Domain→Redis)가 깔끔하게 정리되었습니다. \
  결국 언제든지 바꿔 끼울수있는 그런 구조를 통해 가독성있는 구조를 만든것이 이번에 큰 인사이트를 얻었습니다.\
  특히 파사드에서 응용계층을 또 다시 호출하는 패턴에 대해서 안티패턴이 아니라 충분히 납득할수있는 구조가 될수 있다는 조언을 받을때 막혀있던 시야가 다시한번 넓어지는 느낌을 받았습니다.

> Facade 는 Application 계층의 진입점으로서 이름을 지키고, 응용 계층의 다른 응용 기능을 풀어내 호출하게 한 점은 절대 안티패턴이 아닙니다. 오히려 계층 구조를 명확하게 지키고, 응용 기능을 계층화하여 의존 방향을 잘 지키기 위한 좋은 접근 방식이라고 생각해요. 실제로 현업에서도 트랜잭션 경계 / 캐시 레이어링 등 다양한 목적을 위해 계층 내에서도 세부 계층을 나누어 객체지향적으로 접근하는 편입니다. 예를 들면, 같은 층 내에 있는 2층 침대 같은 거죠.   - 피드백 받은 코드 리뷰

**아쉬웠던 점:**

* ZSET Member 가 만약 10만 넘으면 샤딩 기준은 정했지만, 실제로 언제 나눌지 감각이 부족:\
  아마 이 부분은 충분한 서비스 트래픽을 가정하고 한것이 아니고, 심층적인 요구사항을 상정하고 한것이 아니라 \
  느낀 경험인것 같습니다.&#x20;
* 점수 가중치를 동적으로 튜닝하는 로직은 구현 X:\
  하면 좋겠다는 생각은 하지만, 우선 순위중 후순위에 있어서 미구현하였습니다.
* 여러 랭킹 유형(카테고리별, 브랜드별)이 생기면 Carry-Over 스케줄러가 어떻게 될지 구현 X:\
  하면 좋겠다는 생각은 하지만, 역시나 마찬가지로 우선순위에 밀려서 미구현한 기능이었습니다. \
  이럴경우 각각에 zset 을 만들어서 해야하지 않을까 생각은 하고, 기존 로직에서 확장되게 구성하면 \
  큰 무리없는 기능 구현이 될것이라 생각합니다.

### 3. 다음에 더 깊게 파고들고 싶은 것들

* **Redis 모니터링 지표**를 직접 찍어보면서 ZCARD, ZRANGE 응답시간, 메모리 사용량을 분석해 보고 싶음
* 같은 패턴을 **검색어 랭킹, 실시간 인기 카테고리**에 적용해 보는 연습
* "Redis에 데이터를 얼마나 오래, 얼마나 많이 맡길 수 있을까?"에 대한 구체적 기준 세우기
