# WIL: 오늘도 우리의 과일은 신선한가요? (aka. 우리의 테스트 코드는 바로 검증이 가능한걸까요?)

기간 : 2025/10/27 \~ 2025/11/01

### 서론: 어느덧 테스트 코드는 의미 없는 데이터가 되었다 <a href="#undefined" id="undefined"></a>

프로젝트의 요구사항을 정의하고, 구현 사항을 하나하나 검증하기 위해\
단위 테스트, 통합 테스트, 인수 테스트를 열심히 작성하며 개발을 시작했습니다.

초기에는 테스트 코드가 잘 동작했고, 새로운 기능을 추가하거나 구조를 바꿔도\
아직까지는 충분히 연관관계를 관리하며 검증이 가능하다 생각했습니다.

하지만 프로젝트가 커지고, 복잡한 도메인 간의 연관이 늘어날수록테스트 코드는 점점 더 자주 깨지기 시작합니다.\
이제는 테스트를 수정하는데 많은 리소스가 들어가고, 기한을 위해 일부 테스트는 어쩔 수 없이 비활성화하게 되었습니다.

처음엔 그래도 괜찮다 싶었지만 임시방편이 반복될수록 점점 감당할 수 없는 상황에 도달합니다.\
의존성은 꼬이고, 작은 변경에도 여기저기서 오류가 터지기 시작합니다.

결국 우리가 만든 테스트 코드는 더 이상 서비스 안정성도, 기능 검증도 하지 못하는 의미 없는 “데이터”만 남게 되었습니다.

냉장고에 과일을 넣어 두고 소비하지도, 새로 채워넣지도 않다가, 상한 부분만 도려내다가 결국 전체를 버리고 마는 것과 닮았다고 생각합니다. 끝에는 과일 자체는 없어지고, 껍질이나 씨만 남게 되는 것처럼\
우리의 테스트 코드도 결국 아무 역할 없는 잔해만 남을것입니다.



### 1. 좋은 테스트는 ‘잘 실패하는’ 테스트 <a href="#id-1" id="id-1"></a>

테스트를 처음 시작할 땐 `모든 케이스가 통과하면 성공이고, 커버리지도 높을수록 좋은 거다` 라고 생각했습니다.\
실제로는, 테스트가 항상 초록불만 찍으면 왠지 마음이 편했습니다. (많으면 더 편안했습니다.)

그런데 이번주 동안 TDD 와 테스트 기법에 공부 및 관련 글을 읽으면서 `테스트의 진짜 목적은 ‘성공’이 아니라 ‘예민하게 실패할 줄 아는 것’` 임을 느꼈습니다.

코드에 새로운 기능을 추가하거나, 기존 로직을 바꿨을 때 그 변화를 테스트가 미세하게 잡아내지 못하면\
“내가 뭘 잘못했는지” 확인할 길이 없어집니다. 이런 테스트는, 사실상 ‘신선함을 잃은 과일’처럼 진짜 문제를 인지를 못하게 됩니다.



만약 이 테스트가 아무 변화에도 실패하지 않는다면\
그 테스트는 ‘신선도가 떨어진 것’이라는 경고이기도 합니다.



* 잔액 변경이 바로 인지 되는 경우

```java
@Test
void 잔액_증가_로직이_기존_규칙을_위반하면_테스트가_실패한다() {
    Account account = new Account("user01", 1000);
    account.deposit(500); // 예를 들어 규칙상 최대 입금: 400

    // 비즈니스에서는 최대 입금 한도가 400이라고 가정
    // 규칙 위반 시 바로 실패해야 테스트가 우리가 검증하던걸 더 명확히 검증 가능
    assertThat(account.getBalance()).isLessThanOrEqualTo(1400); // 1000 + 400
}
```

* 할인율 적용에 대하여 예민하게 반응하는 경우

```java
@Test
void 할인율_허용_범위_초과시_테스트가_바로_실패한다() {
    Product product = new Product("item", 10000);

    // 0~50%만 허용, 80% 같은 필드 변경이 있으면 바로 실패해야 비즈니스의 의도를 충분히 검증 가능
    assertThrows(IllegalArgumentException.class, () -> {
        product.setDiscountRate(80); // 허용범위 초과
    });
}
```

만약 이 테스트가 아무 변화에도 실패하지 않는다면\
그 테스트는 ‘신선도가 떨어진 것’이라는 경고이기도 합니다.

테스트 코드를 **단순히 버그 예방용이 아니라, 동료와 미래의 나에게 남길 최소한의 예의와 자신에 대한 인수인계 문서** 로 인지하게 되었습니다. 내가 진짜 검증하려는 것이 분명하다면 그 테스트가 실패할 때마다 오히려 안도감이 들것입니다.\
이런 마음가짐이 “잘 실패하는 테스트”가 주는 중요한 의미라고 생각합니다. (물론 너무 많이 오류가 발생하면 여전히 힘듭니다.)





### 2. 도메인 모델은 DB랑 상관이 없다.

사실 이 내용을 멘토링때 들었을때 당황했다. java 의 객체와 RDB  테이블간에 불일치하는 부분을 해소하기 jpa 를 사용하는거고 JPA 엔티티와 도메인 모델을 거의 동일시했었습니다. 테이블 컬럼 = 엔티티 필드 = 도메인 객체 라고 이해를 했었습니다.

“잘 실패하는 테스트”의 핵심은 **내가 검증하고 싶은 비즈니스 로직이 제대로 격리되어 있어야** 한다는 점에 연결됩니다.

그런데 설계가 복잡해지고, 레거시 DB 구조가 요구사항과 계속 어긋나기 시작하면서\
이 둘이 완전히 다를 수밖에 없다는 사실을 생각하였습니다.&#x20;

**도메인 모델은 ‘내 비즈니스가 원하는 상태와 규칙’을 담은 인메모리 객체라 봐도 된다는** 멘토님의 의견처럼\
이걸 어떻게 저장(영속화)할지는 완전히 별개의 문제이며, 테스트 역시 “DB에 뭐가 들어갔는지”보다 \
도메인 모델이 의도한 대로 동작하는지에 집중해야 잘 실패하는 테스트가 탄생할 수 있습니다.

예를 들어,\
테스트 더블(Fake 등)로 데이터베이스와 분리해서 도메인 규칙만 검증하면\
내가 정말 검증하고 싶은 행위에 집중할 수 있습니다.

```java
class InMemoryUserRepository implements UserRepository {
    private Map<Long, User> users = new HashMap<>();

    public void save(User user) {
        users.put(user.getId(), user);
    }

    public User findById(Long id) {
        return users.get(id);
    }
    // … 진짜 DB와 무관하게, 비즈니스 로직에만 신경 쓸 수 있음
}

@Test
void 사용자_포인트_충전_로직_테스트() {
    User user = new User("홍길동", 100);
    user.chargePoint(500);
    assertThat(user.getPoint()).isEqualTo(600); // DB와 관계없이, 비즈니스 규칙에만 집중
}
```

물론 해당 예시 코드 처럼 테스트를 이렇게 구현을 하지 않을수 있고, 보다 다양한 영속화 가능 구현체에 의존하여 테스트를 검증할 수 있습니다. 하지만 DB랑 상관없이 우리가 검증하고 싶은 것에 편하게 집중할 수 있게 함으로서 테스트 코드의 신선도를 오래 유지할 수 있다는 걸 배우게 됐습니다. \




### 3. 유효성 검사는 두 번 해도 괜찮다, 오히려 더 안전하다 <a href="#id-3" id="id-3"></a>

도메인 모델과 DB(데이터 저장 계층)를 분리하는것이 좋다는건 느꼈지만, 실제 통합 과 E2E 테스트를 하였을때 들었던 고민은 입력 데이터의 유효성 검증은 어디 까지 해야하는건가? 라는걸 마주쳤습니다.&#x20;

처음엔 컨트롤러에서만 한 번 필터링하면 충분하다고 생각했지만, 여러 팀원 분들과 멘토분들의 이야기들 듣고 생각한것은\
각 계층이 '진짜 가져야 할 책임'을 분리해서 지켜야 시스템 전체가 신선하게 유지되고, 각각의 역할이 명확해진다는 것이였습니다.

* **컨트롤러/DTO 레벨**에서는\
  외부에서 들어오는 데이터의 일차적인 형식(문자열 길이, 필수 값 등)을 먼저 걸러냅니다.\
  즉, `입구에서 불량품을 빠르게 걸러내는 역할` 입니다.
* **도메인/엔티티 객체**에서는\
  그 객체가 실제로 비즈니스 규칙(사업적 진실, 무결성)을 정확하게 갖추었는지 스스로 책임져야만 합니다.\
  즉, `내부에서 불량품을 철저히 막아내는 역할` 입니다.

컨트롤러에서 빠른 실패(early exit)를 구현하고, 도메인에서는 비즈니스 요구사항을 위한  객체에 대해 문제가 없는지에 유효성 검사. 검증하다는 행위는 같지만,  각자 의미가 다르다는 걸 배우게 되었습니다.



### 4. 내 시작과 끝은 어디인지 정의하는 게 중요하다 <a href="#mocks-stubs-fakes" id="mocks-stubs-fakes"></a>

테스트를 작성하면서 ‘End-to-End(E2E)’라는 단어가 잘 안읽혔다. (사실 api 테스트라고 지금 까지 작성을 했다. )\
e2e 니까 처음부터 끝까지 모든 걸 검증하는 거라고 막연히 생각했다.

그런데 멘토링에서 나온 이 주제는 실제로 테스트를 쓰다 보니\
내가 소속된 팀, 내가 맡은 서비스에 따라 '끝'의 정의가 조금씩 다르다는 걸 알았다.

프론트엔드 개발자에겐 “실제 사용자 조작 → 브라우저 → 서버 API 응답”이 끝이고,\
백엔드 개발자 입장에선 “HTTP 요청 → 비즈니스 로직 → DB 반영”까지가 시작과 끝이었다.

그러다보니 E2E 테스트도 내가 책임지는 시스템 범위를 정확히 알아야 ‘진짜 신선한 테스트’가 뭔지 고민할 수 있었다.

예를 들어, 내가 작성한 회원가입 API의 E2E 테스트는\
`HTTP 요청을 받아서 → DB에 저장되고 → 다시 정상적으로 응답이 반환되는지.`     까지를 \
내가 할 수 있는 최종적인 검증이 이뤄진다.

반면 프론트엔드 관점에서 인수(E2E) 테스트를 할 땐 사용자 시나리오가 훨씬 더 폭넓게 다가온다.

> 회원가입 화면에서 입력창에 이름·이메일·패스워드를 입력 → 회원가입 버튼 클릭 → 로딩 표시 → 성공 메시지 확인 → 브라우저가 자동으로 로그인 페이지로 이동”

이 일련의 과정을 실제 브라우저에서 시뮬레이션해서 `진짜 유저 입장에서 회원가입이 끊김 없이 잘 진행되는지` 를 최종적으로 인수하는 게 목적이 된다.

더 이상 바깥 영역까지 강박적으로 확장할 필요 없이 내가 책임지는 경계(End)를 명확히 그어서\
그 범위 안에서 검증이 민감하게 일어나도록 신경쓰는 게 오히려 효율적이라는 생각이 들었다.

End-to-End는 기술 용어보다 '내가 어디까지를 책임질 것인가'에 대해 정의를 하고 이걸 흔들리지 않고 유지하는것이 \
관건이라는걸 배울 수 있었다. 어떤 기능을 테스트할 때 그 테스트의 진짜 `끝(End)` 이 어디인지를 먼저 정의하고, \
내가 신선함을 책임져야 할 영역에 집중하는 게 중요하다 생각한다.&#x20;



### 회고: 냉장고의 과일의 신선도를 유지하라

사실 이번 주에 내가 했던 작업은 복잡한 도메인이 막 얽혀 있는 대규모 실무 과제는 아니었다.\
오히려 테스트라는 기술 자체를 익히고, 패턴과 구조, 역할의 본질을 내 손으로 직접 만져보는 경험에 집중했던 시간이었다.

처음엔 작은 단위/통합 테스트부터 시작해 손에 익히고, 조금씩 응용해 가며\
테스트 코드가 어떻게 서비스 신선도, 안정성을 지켜주는지 몸으로 느껴보려 했다.

냉장고의 과일에 비유하자면 아직 다양한 과일이 막 섞여서 복잡하지는 않았지만\
기본적인 관리방법, 신선도 체크 습관부터 확실히 익히는 게앞으로 더 복잡한 시스템을 만났을 때\
테스트 코드 역시 잘 살아 있을 수 있는 기초가 된다는 걸 알게 됐다.

테스트에 대한 부담감이나 완벽주의보다 기본부터 자주 점검하는 습관, `잘 실패하는 테스트` 가 주는 경고, \
책임 분리와 검증의 본질 등 신선도를 유지하는 자세가 먼저라는 걸 깨달았다.
