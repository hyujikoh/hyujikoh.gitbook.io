# 이벤트

## 서론. 이 글을 작성하게 된 이유

이벤트를 어떻게 이해해야 할까?\
이번에 주문·결제·쿠폰·유저 행동 추적 기능을 구현하면서,\
가장 먼저 정의한건 아래와 같습니다.

> 이벤트는 “누군가 관심을 가지고 있어야 의미가 있는 과거의 사건”이다.

“결제가 완료되었다”, “주문이 생성되었다”, “좋아요가 눌렸다” 같은 일들은\
그 자체로도 의미가 있지만, 사실 더 중요한 건 "이 사건에 누가 관심을 가지는가" 라고 생각합니다.

* 결제 완료: 주문 도메인, 포인트 도메인, 쿠폰 도메인 등
* 좋아요 변경: 상품 통계, 캐시 업데이트, 추천 시스템, 유저 행동 분석 등

이벤트를 도입하기 전의 코드는 보통 이렇게 흘러갑니다.

* 주문 서비스가 결제, 포인트, 쿠폰, 재고, 로그 전송까지 모두 직접 호출한다.
* 한 메서드 안에서 여러 도메인의 관심사가 뒤섞인다.
* 새로운 요구사항이 생기면, 항상 기존 코드를 다시 열어봐야 한다.

이 구조의 공통점은, “모든 관심사를 한 곳에서 직접 관리하려고 한다”는 것에 있었습니다.

그래서 이번 기능들을 구현하면서 의식적으로 이런 질문들이 나왔습니다.

* 이 사건을 “알고만 있으면 되는” 사람은 누구인가?
* 이 사건에 “관심이 있는” 주체는 어디까지인가?
* 그렇다면, 이 사건을 그들에게 “알린다”는 것을 코드로 어떻게 표현할 것인가?

그 과정에서 자연스럽게 이벤트를 도입하게 되었습니다.

* 도메인 객체가 “이런 일이 일어났다”고 알리는 도메인 이벤트
* 응용 계층이 “사용자가 이런 행동을 했다”고 알리는 사용자 행동 이벤트
* 이 둘을 “관심 있는 쪽”에서만 받아 처리하도록 분리하는 구조

이번에 작성하는 글은 Spring Event 에 대해 딥다이브 한 내용을 소개하는게 아니라 고민의 과정을 정리한 글입니다.\
이벤트를 거창한 기술이나 패턴이 아니라,

“어떤 사건을, 누구에게까지 알려줄 것인가” 를 코드로 표현하는 방법 \
으로 바라보며 설계해 본 경험을 공유하려 합니다.

***

## 1장. 이벤트가 필요해 보이기 시작한 순간들 <a href="#id-1" id="id-1"></a>

이벤트를 “누군가 관심을 가지고 있어야 의미가 있는 과거의 사건”이라고 정의했을 때,\
가장 먼저 떠올랐던 곳은 **주문 생성 메서드**였습니다.

제가 가진 카드 결제용 주문 생성 메서드는 대략 아래와 같은 흐름입니다.

```java
@Transactional
public OrderInfo createOrderForCardPayment(OrderCreateCommand command) {
    UserEntity user = userService.findByUsernameWithLock(command.username()); // 사용자 조회 + 락

    // 상품/쿠폰 검증 및 준비
    for (OrderItemCommand item : command.orderItems()) {
        ProductEntity product = productService.getProductDetailLock(item.productId()); // 재고 락
        // 재고/쿠폰 검증 ...
    }

    OrderCreationResult creationResult =
            orderService.createOrderWithItems(user.getId(), orderableProducts, coupons, quantities); // 주문 생성

    productService.deductStock(...);          // 재고 차감
    couponService.consumeCoupons(...);       // 쿠폰 사용

    return OrderInfo.from(creationResult.order(), creationResult.orderItems());
}

```

이 안에서 실제로 일어나는 일은 다음과 같습니다.

* 사용자 조회 및 검증 (+ 락)
* 상품 재고 확인 및 락
* 쿠폰 유효성 검증
* 주문 및 주문 항목 생성
* 재고 차감
* 쿠폰 사용 처리

겉으로 보면 “주문 하나 처리하는 메서드”이지만,\
실제로는 여러 도메인의 관심사가 한데 섞여 있습니다.

* User: 주문자의 정보와 상태
* Product: 재고, 주문 가능 여부
* Coupon: 사용 여부, 소유자 검증

여기서 제가 느낀 핵심 문제는 두가지였습니다.

#### 1. 응용 메서드에 쌓여가는 책임

요구사항이 생길 때마다 자연스럽게 이런 식으로 붙습니다.

> “쿠폰 사용도 같이 차감해 주세요.”
>
> “특정 조건이면 쿠폰도 자동 발급해 주세요.”
>
> “결제 성공/실패 로그를 데이터 플랫폼으로 보내주세요.”
>
> “주문 행동 패턴을 분석할 수 있게 로그 남겨주세요.”

결과적으로, 응용 계층은 “주문을 조율하는 계층”을 넘어\
**모든 관심사의 집합소**가 됩니다.

#### 2. 도메인 간 결합과 변경 비용

요구사항이 생길 때마다 자연스럽게 이런 식으로 붙습니다.

```java
productService.deductStock(...);
couponService.consumeCoupons(...);
dataPlatformClient.sendOrderData(...);
```

각 도메인의 책임은 자연스럽지만,\
“주문”이라는 사건에 관심 있는 모든 도메인을\
응용 메서드가 **직접 알고 있다는 것**이 문제라고 생각했습니다.

* 쿠폰 정책이 바뀌면 → 주문 코드 수정
* 데이터 플랫폼 스펙이 바뀌면 → 주문 코드 수정
* 행동 추적 요구가 바뀌면 → 주문 코드 수정

“관심 있는 사람”이 늘어날수록, 주문 응용 클래스를 계속 확인해봐야 했습니다.

***

이렇게 길을 잃을때마다 서론에서 이야기한 이벤트의 정의를 다시 말씀드리자면

> 이벤트는 “누군가 관심을 가지고 있어야 의미가 있는 과거의 사건”이다.

“주문이 생성되었다”는 사건을 기준으로 보면:

* 주문 도메인: 주문 생성 자체에 관심
* 상품 도메인: 재고를 얼마나 줄였는지에 관심
* 쿠폰 도메인: 어떤 쿠폰이 어디에 사용됐는지에 관심
* 분석/트래킹: 사용자가 어떤 방식으로 주문했는지에 관심

이때 응용 메서드가 맡아야 할 역할은, 모든 일을 직접 처리하는 것이 아니라:

1. “주문이 생성되었다”는 사실을 정확하게 만들고
2. 그 사실을, **관심 있는 주체들에게 알려주는 것**

이라는 생각이 들었습니다.

그래서 이번에 도메인과 응용 레벨에서 이렇게 나눠 보기로 했습니다.

* 도메인 객체가 “이런 일이 일어났다”고 기록하는 **도메인 이벤트**
* 응용 계층이 “사용자가 이런 행동을 했다”고 기록하는 **사용자 행동 이벤트**
* 이 사건에 관심 있는 쪽에서만 이를 구독해 처리하는 **이벤트 핸들러/리스너**

1장에서 하고 싶었던 이야기는 단순합니다.

> 이벤트를 고민하기 전에,\
> 먼저 “지금 이 응용 메서드가 떠안고 있는 관심사”를\
> 차분히 들여다보는 단계가 필요했다는 것.

***

## 2장. 로컬 이벤트 vs 글로벌 이벤트: 같은 이벤트 , 다른 도구

