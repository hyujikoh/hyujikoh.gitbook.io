# 내 레디스는 이정도의 값어치가 있을까?



## 서론. 이 글을 작성하게 된 이유 <a href="#undefined" id="undefined"></a>

캐시는 논리적인 개념이고, Redis는 이를 구현한 훌륭한 도구입니다.

인덱스와 MV, 빠른 응답을 위해 캐시라는 방식을 고민했고 Redis를 선택했습니다.

캐싱은 본질적으로 휘발성이기에, RDB라는 주 데이터 흐름을 캐시라는 임시 저장소로 분기하는 작업입니다. 비유하자면 캐시는 큰 물줄기를 작은 물줄기로 나누어 받아 담는 항아리이고, 서버 재시작은 그 항아리를 깨뜨리는 일입니다. 깨진 항아리의 물은 다시 채워야 하죠. 물론 보다 복잡한 기술적 개념이 있지만 생략하겠습니다.

이번 글에서는 제가 겪은 문제를 캐시 메모리라는 **항아리를 적절히 필요한 것로 채웠는지, 깨졌을 때 대비책을 마련했는지** \
돌아보는 시간을 가져보려 합니다.

## 문제 정의 및 상황 확인&#x20;

### 내 데이터의 순위는 어디에서 꺼낸다음 정리해야 할까?

자주 이용하는 데이터 현황을 실시간으로 보여주기. 한줄로 정리되는 단순한 요구사항입니다.

Kafka로 들어오는 조회, 장바구니, 구매 이벤트를 랭킹에 반영하고 사용자는 모바일, 웹에서 스크롤, 페이징하며 봅니다.

RDB에 MV 성격의 점수 테이블을 만들고 내림차순 쿼리를 짭니다.

```java
SELECT product_id, SUM(score) as total_score
FROM product_events 
WHERE date = CURDATE()
GROUP BY product_id 
ORDER BY total_score DESC 
LIMIT 100 OFFSET 900
```

**가장 큰 문제는 GROUP BY입니다.** 인덱스를 product\_id, date, score 순으로 만들어도 GROUP BY 때문에 풀스캔을 피할 수 없습니다. MySQL 옵티마이저는 GROUP BY를 먼저 처리한 뒤 ORDER BY 정렬을 합니다. 결과적으로\
**인덱스가 GROUP BY 앞에서는 무용지물**입니다.

MV(Materialized View)로 집계 테이블을 만들어 봤지만,\
실시간 Kafka 이벤트 반영이 늦어지고 페이징 깊어질수록 여전한 병목이었습니다.&#x20;

결국 관계형 DB에서 실시간 집계 + 페이징은 근본적인 한계가 있습니다.



### 가설 세우고 검증

결국 대안으로 사용하기 위한 Redis 를 사용하기 앞서 Redis가 왜 빠른지 궁금했습니다. \
싱글 스레드인데 MySQL보다 빠른 원리에 대해서 의구심을 가졌습니다.&#x20;

보통 성능은 멀티스레드로 높인다고 생각합니다. 하지만 Redis는 오히려 싱글 스레드를 고집합니다.

**왜 싱글 스레드인가**

* 멀티 스레드에서 발생하는 컨텍스트 스위칭 비용이 없습니다. 스레드가 바뀔 때 CPU가 상태를 저장하고 복구하는 오버헤드가 제거됩니다.
* Lock 메커니즘이 불필요합니다. 여러 스레드의 Race Condition이나 Deadlock 이 redis 에서는 발생하지 않습니다.. ZINCRBY 같은 명령은 원자적으로 동작하기 때문에 원자성이 보장되기 때문입니다.
* Redis 의 성능을 결정하는건 메모리와 네트워크 I/O의 병목입니다. \
  Redis는 메모리 내 연산이므로 네트워크 대역폭이 성능을 결정합니다.

