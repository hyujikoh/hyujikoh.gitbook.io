---
hidden: true
---

# kafka deep dive is very important

카프카 시나리오&#x20;



2개의 토픽  = 각 1개 의 파티션 사용

1개의 브로커



이런 상황에서 동시성 실행

그랬을경우

아웃박스에 데이터 저장 약 20866

인박스에 데이터 저장 동일한 20866 저장

단&#x20;

아웃박스 데이터 최초 생성 시점 과 최후 생성 시점 각각 발행 시점

2025-12-18 14:52:43.786329 , 2025-12-18 14:52:44.770610

2025-12-18 14:53:31.667756, 2025-12-18 14:56:27.884997



이벤트 핸들 저장 시점 (최초 화 최후)

2025-12-18 14:52:47.113302 , 2025-12-18 14:56:32.608570





상황 2&#x20;

파티션 각각 3대로 하고 컨슈머는 동일하게 1대



상황 3&#x20;

파티션 3대 컨슈머 3대 각각 병렬로 데이터 저장









상황: 중요한 책 3권을 보관해야 함

파티션 = 책의 종류\
📖 책 A (파티션 0)\
📗 책 B (파티션 1)\
📘 책 C (파티션 2)\
브로커 = 도서관 지점\
🏢 강남 도서관 (브로커 1)\
🏢 홍대 도서관 (브로커 2)\
🏢 잠실 도서관 (브로커 3)\
복제 팩터별 보관 방식\
복제 팩터 1 (현재 설정)\
📖 책 A → 강남 도서관에만 보관\
📗 책 B → 홍대 도서관에만 보관\
📘 책 C → 잠실 도서관에만 보관\
문제: 강남 도서관이 화재나면 책 A는 영원히 사라짐 😱

복제 팩터 2\
📖 책 A → 강남 도서관 + 홍대 도서관 (2곳에 복사본)\
📗 책 B → 홍대 도서관 + 잠실 도서관 (2곳에 복사본)\
📘 책 C → 잠실 도서관 + 강남 도서관 (2곳에 복사본)\
장점: 도서관 1곳이 화재나도 다른 곳에 복사본 있음 ✅

복제 팩터 3\
📖 책 A → 강남 + 홍대 + 잠실 (3곳 모두에 복사본)\
📗 책 B → 강남 + 홍대 + 잠실 (3곳 모두에 복사본)\
📘 책 C → 강남 + 홍대 + 잠실 (3곳 모두에 복사본)\
장점: 도서관 2곳이 화재나도 1곳에는 복사본 있음 ✅✅

💾 컴퓨터 파일 예시\
상황: 중요한 파일 3개를 백업

복제 팩터 1\
📄 파일1.txt → 컴퓨터A에만 저장\
📄 파일2.txt → 컴퓨터B에만 저장\
📄 파일3.txt → 컴퓨터C에만 저장\
위험: 컴퓨터 하나 고장나면 해당 파일 손실

복제 팩터 3\
📄 파일1.txt → 컴퓨터A + 컴퓨터B + 컴퓨터C (3곳에 동일한 파일)\
📄 파일2.txt → 컴퓨터A + 컴퓨터B + 컴퓨터C (3곳에 동일한 파일)\
📄 파일3.txt → 컴퓨터A + 컴퓨터B + 컴퓨터C (3곳에 동일한 파일)\
안전: 컴퓨터 2대 고장나도 1대에는 모든 파일 있음

핵심 정리\
파티션 수: 몇 개의 서로 다른 데이터로 나눌지\
복제 팩터: 각 데이터를 몇 곳에 백업할지\
현재 설정 (복제 팩터 1): 백업 없음, 빠르지만 위험 운영 설정 (복제 팩터 3): 2곳 백업, 안전하지만 용량 3배





아 그러니까 각각 브로커에 동일한 구성 셋트로 3개가 각각 있다는 이야기지 ?

메인 파티션 작업 이외에도 복제 파티션에도 실시간으로 전파가 되는거야? 또한 해당 복제 파티션도 동일하게 운영하는데 처리가 되는거야?

Kiro\
좋은 질문입니다! 하지만 몇 가지 오해가 있어서 정확히 설명드리겠습니다.

❌ 오해: "각 브로커에 동일한 구성 셋트로 3개가 각각 있다"\
실제로는 이렇습니다:

복제 팩터 3, 파티션 3개인 경우\
파티션 0: 📄A 데이터\
├── 브로커1: 📄A (Leader) ← 읽기/쓰기 담당\
├── 브로커2: 📄A (Follower) ← 백업만\
└── 브로커3: 📄A (Follower) ← 백업만

파티션 1: 📄B 데이터\
├── 브로커1: 📄B (Follower) ← 백업만\
├── 브로커2: 📄B (Leader) ← 읽기/쓰기 담당\
└── 브로커3: 📄B (Follower) ← 백업만

파티션 2: 📄C 데이터\
├── 브로커1: 📄C (Follower) ← 백업만\
├── 브로커2: 📄C (Follower) ← 백업만\
└── 브로커3: 📄C (Leader) ← 읽기/쓰기 담당\
🔄 실시간 전파: YES!\
Producer가 메시지 전송 시:

Leader 파티션에만 쓰기\
Leader가 Follower들에게 실시간 복제\
모든 복제 완료 후 Producer에게 응답\
Producer → 브로커2(Leader) → 브로커1,3(Followers)\
↓\
"복제 완료!" 응답\
❌ 복제 파티션 처리: NO!\
오직 Leader만 처리합니다:

Producer (쓰기)\
✅ Leader 파티션에만 쓰기 가능\
❌ Follower 파티션은 쓰기 불가\
Consumer (읽기)\
✅ Leader 파티션에서만 읽기\
❌ Follower 파티션은 읽기 불가 (백업 전용)\
🚨 장애 상황에서만 역할 변경\
브로커2 (Leader) 장애 시:

Before: 브로커2(Leader) ← Consumer가 여기서 읽음\
After: 브로커1(New Leader) ← Consumer가 여기서 읽음\
브로커3(Follower)\
💡 핵심 정리\
복제: 실시간으로 동기화됨 ✅\
처리: 오직 Leader만 처리 (Follower는 대기)\
목적: 장애 대비용 백업 (성능 향상 아님)\
비용: 저장 공간 3배, 네트워크 오버헤드\
따라서 복제 팩터는 "성능 향상"이 아니라 "안정성 향상"을 위한 설정입니다!





