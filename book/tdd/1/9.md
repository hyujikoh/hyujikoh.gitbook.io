# 9장 우리가 사는 시간

#### 현재 까지의 진행상태&#x20;

* [ ] $5 + 10CHF = 10$(환율이 2:1  일 경우)
* [x] ~~$5\*2 = $10~~
* [x] ~~amount를 private로 만들기()~~
* [x] ~~Dollar 부작용~~
* [ ] Money 반올림
* [x] ~~equals()~~
* [ ] hashCode()
* [ ] Equal null
* [ ] Equal Object&#x20;
* [x] ~~5CHF \* 2 = 10CHF~~
* [ ] **Dollar/Franc 중복**
* [x] ~~공용 equals~~
* [ ] **공용 times**
* [x] ~~Franc 과 Dollar 비교하기~~
* [ ] 통화?
* [ ] testFranMultiplication 테스트는 제거 해야할까??

지금까지 많이 한것 같지만, 하면서 테스트 해야하는 것들도 늘어나가고 있다.👻

할일 목록에서 어떤 걸 해결하면 귀찮고 불필요한 하위 클래스를 제거 하는데 도움이 될까? \
이번 장에서는 통화 개념을 도입을  해보도록 하겠다.

어떻게 하면 통화 개념을 도입하기 위해 테스트를 구현 할 수 있을까?? 통화를 표현 하는데, 많은 요소들을 고려 해야 한다. 이것들을 표현하기 위해 복잡한 객체를 원할 수 도 있다. 또한 필요한 것들만 만들어지는 경량 팩토리를 사용할 수도 있지만, 그런 것들 대신 문자열을 도입하는 것부터 시작 하기로 하자.

{% code fullWidth="false" %}
```java
// 이번에 시도할 테스트
@Test
public void testCurrency(){
    Assertions.assertTrue("USD".equals(Money.dollar(1).currency()));
    Assertions.assertTrue("CHF".equals(Franc.dollar(1).currency()));
}

```
{% endcode %}

다음과 같은 테스트를 통과하기 위해서 Money 클래스에  currency() 를 선언할 뿐만 아니라, 자식 클래스에서도 구체화 해야한다.&#x20;

```java
// Money.class
public abstract class Money {
    abstract String currency();
}

// 부모클래스의 추상메소드를 구체화 

// Dollar.class
public class Dollar extends Money{
    @Override
    String currency() {
        return "USD";
    }
}


// Franc.class
public class Franc extends Money{
    @Override
    String currency() {
        return "CHF";
    }
}
```

지금과 다르게 각각 두클래스를 모두 포함할 수 있는 동일한 구현이 필요한 상황이다.

통화 필드를 인스턴스 변수에 저장하고 메서드에서는 그걸 반환하게 만들 수 있을 것 같다.&#x20;

```java
// Dollar.class
public class Dollar extends Money{

    private String currency;
    
    Dollar(int amount){
        this.amount = amount;
        this.currency = "USD";
    }
    

    @Override
    String currency() {
        return currency;
    }
}


// Franc.class
public class Franc extends Money{

    private String currency;
    
    Franc(int amount){
        this.amount = amount;
        this.currency = "CHF";
    }

    @Override
    String currency() {
        return currency;
    }
}
```

이제 두 curreny() 가 동일하므로 변수 선언과 currency() 구현을 둘다 Money 로 보내도 된다!

```java
// Money.class
public abstract class Money {
    protected int amount;
    protected String currency;

    String currency() {
        return currency;
    }
    abstract Money times(int mul);


    public boolean equals(Object o){
        Money money = (Money) o;
        return amount == money.amount && this.getClass() == o.getClass();
    }

    public static Dollar dollar(int amount){
        return new Dollar(amount);
    }

    public static Franc franc(int amount){
        return new Franc(amount);
    }
}


// 부모클래스의 추상메소드를 구체화 

// Dollar.class
public class Dollar extends Money{
    Dollar(int amount){
        this.amount = amount;
        this.currency = "USD";
    }
    Money times (int mul){
        return new Dollar(amount * mul);
    }
}


// Franc.class
public class Franc extends Money{
    Franc(int amount){
        this.amount = amount;
        this.currency = "CHF";
    }

    Money times (int mul){
        return new Franc(amount * mul);
    }

}
```

지금 까지 리팩토링 및 개선된 코드는 다음과 같다. 각각의 통화 를 하드코딩으로 넣었는데, 이럴 필요없이 팩토리 메소드에 인스턴스 변수를 넘김으로 개선 시킬수 있게 되었다.(추가 작성필요)

